var packageJson = require('../package.json'),
    banner = "// Generated by SugarLisp v" + packageJson.version + "\n",
    bannerables = ['.slisp', '.ls', '.sugar'],
    isFunction = /^function\b/,
    returnStmtIllegalCode = /^[\s]*return\b|^[\s]*if\b|^[\s]*for\b|^[\s]*while\b|^[\s]*switch\b|^[\s]*break\b|^[\s]*console\b/,
    sl = require('sugarlisp-core/sl-types'),
    dialoader = require("sugarlisp-core/dialect-loader"), // avoid circular dependency (need to investigate)
    macros = require('sugarlisp-core/macro-expander'),
    reader = require('sugarlisp-core/reader'),
    src = require('sugarlisp-core/source'),
    utils = require('sugarlisp-core/utils'),
    ctx = require('sugarlisp-core/transpiler-context'),
    beautify = require('js-beautify').js_beautify,
    fs,
    path;

var debug = require('debug')('sugarlisp:transpiler:info'),
    trace = require('debug')('sugarlisp:transpiler:trace'),
    //lsinfo = function() { console.log.apply(this, arguments); };
    lsinfo = require('debug')('sugarlisp:info');

// these node modules unavailable/unused in the browser
// note: reliably determining where we're running is complicated
//   because the Atom editor appears as both node *and* a browser!
try {
  fs = require('fs');
  path = require('path');
}
catch(e) {
  debug("failed requiring fs and path (assume we're running in a browser)");
}

function sanitizePrelude(prelude) {

  // we add a newline ourselves - so reduce 2 in the prelude to one:
  var sanitized = prelude.replace(/^\n/, '');
  //sanitized = sanitized.replace(/\n$/, '');
  // convert lispy line comments (";;" and ";") to javascript's "//"
  sanitized = sanitized.replace(/\;\;/g, '//').replace(/\;/g, '//');

  if(!ctx.options.transpile.includeComments && !sanitized.match(/^\s+$/)) {
    return "";
  }

  return sanitized;
}

var transpileExpressions = function(forms, noReturnStmt) {
    ctx.indent += ctx.indentSize;
    var transpiled = sl.transpiled(),
        indentstr = " ".repeat(ctx.indent);

    // a prelude on the top forms may be e.g.
    // comments from the top of a file.
    if(forms.prelude) {
      transpiled.push([sanitizePrelude(forms.prelude)]);
    }

    forms.forEach(function(form, formPos, forms) {
        var nextForm = null;

        if (Array.isArray(form)) {
            nextForm = transpileExpression(form)
        } else {
            nextForm = form
        }

        if (nextForm) {
            var nextFormStr = nextForm.toString();
            var nextFormStrTrimmed = nextFormStr.trim();

            // note: originally it was the "context" that held the "noSemiColon"
            //   flag but that has been a problem - want to move to the transpiled
            //   list's *forms* having that directly (which is more controlled)
            var endline = (nextForm.noSemiColon || ctx.noSemiColon ? "" :
              // avoid double semicolons regardless
              (nextFormStrTrimmed.charAt(nextFormStrTrimmed.length-1) === ';' ? "" : ";"));
            ctx.noSemiColon = false;
            endline += (nextForm.noNewline || ctx.noNewline ? "" :
              // avoid double newlines
              (nextFormStr.charAt(nextFormStr.length-1) === '\n' ? "" : "\n"));
            ctx.noNewline = false;

            // eliminate extra returns from compile macros
            if(nextForm.prelude && !nextForm.__compiletimemacro) {
              transpiled.push([sanitizePrelude(nextForm.prelude)]);
            }

            // we (typically) add a return on the last expression for
            // all but the topmost expressions (i.e. topmost in a file)
            var optionalReturnStmt = "";
            if (!noReturnStmt && formPos === forms.length-1 && ctx.indent) {
                // but not always:
                if((typeof ctx.options.transpile.implicitReturns === 'undefined' ||
                  ctx.options.transpile.implicitReturns) &&
                  !(nextForm.noReturn || ctx.noReturn) &&
                    !returnStmtIllegalCode.test(nextFormStr))
                {
                  optionalReturnStmt = "return ";
                }
                ctx.noReturn = false;
            }

            if(!reader.isignorableform(nextForm)) {
              // note we push *nextForm* not *nextFormStr* to preserve line/cols
              transpiled.push([indentstr + optionalReturnStmt, nextForm, endline]);
            }

            if(nextForm.endPrelude) {
               transpiled.push([sanitizePrelude(nextForm.endPrelude)]);
            }
        }

        // output any before/after code
        // (most likely the result of binding expressions e.g. the "#=")
        if(ctx.beforeCode && ctx.beforeCode.length > 0) {
          ctx.beforeCode.forEach(function(beforecode) {
            transpiled.unshift([ctx.margin(),beforecode.toString(),"\n"]);
          });
          ctx.beforeCode = [];
        }
        if(ctx.afterCode && ctx.afterCode.length > 0) {
          ctx.afterCode.forEach(function(aftercode) {
            transpiled.push([ctx.margin(),aftercode.toString(),"\n"]);
          });
          ctx.afterCode = [];
        }
    })

    // an endPrelude at the top level may be
    // e.g. comments at the end of a file
    if(forms.endPrelude) {
      transpiled.push([sanitizePrelude(forms.endPrelude)]);
    }
    ctx.indent -= ctx.indentSize;
    return transpiled;
}

// transpileExpression returns a transpiled expression
// with any prelude (leading whitespace or comments)
// prepended so they pass thru to the generated code
var transpileExpression = function(form, options) {

  var transpiled = transpileExpressionAlone(form, options);
  if(transpiled) {
    // a prelude is comments or white space preceding a form
    transpiled.prelude = transpiled.prelude || form.prelude ||
      (Array.isArray(form) && form.length > 0 ? form[0].prelude : undefined);

    // an end prelude is comments or white space preceding
    // the end of a list
    transpiled.endPrelude = transpiled.endPrelude || form.endPrelude ||
      (Array.isArray(form) && form.length > 0 ? form[0].endPrelude : undefined);
  }

  // now that this expression is completely transpiled
  if (Array.isArray(form)) {
    // find binding code to be included before/after this expression
    // (this is our approach to automatically invoking "reactor" functions)
    ctx.beforeCode = includeBindingCode("before", form, ctx.beforeCode);
    ctx.afterCode = includeBindingCode("after", form, ctx.afterCode);
  }

  return transpiled;
}

// transpileExpressionAlone is a helper for transpileExpression above
// (call it instead)
var transpileExpressionAlone = function(form, options) {

    if (!form || !form[0]) {
        return null;
    }

    options = options || {};
    var source = sl.sourceOf(form);
    var command = sl.valueOf(form[0]);
    lsinfo("command: " + command);

    if(command) {
      var msg = 'looking up keyword function for "' + command + '"';
      debug(source.message_src_loc(msg, form[0], {file:false}));
    }
    else {
      debug('command without a symbol in first position!!',
        typeof form[0], "array:", Array.isArray(form[0]));
    }

    if (typeof command === "string") {
        // accept javascript strings as return values from keyword functions
        // note: they typically return sl.transpiled() objects, returning strings
        //   is the exception not the rule.
        var result = execKeywordFnFor(command, form);
        if(result && typeof result === "string") {
          var snode = sl.transpiled();
          snode.push(result);
          result = snode;
        }
        if(result) {
          // is this a compile time macro function e.g. a (macro name ...)
          // form or a function prefixed by #keyword?
          if(form.__macrofn || result.__macrofn) {
            var mName;
            if(!sl.isList(form[1]) && sl.isList(form[2])) {
                mName = form[1];
            }
            else {
              form.error("compile time macro functions must have a name.");
            }
            debug("registering compile time macro function:", sl.valueOf(mName));
            // eval the javascript generated for the macro function
            var macrofncode = result.toString();
            trace("the macro function code is:", macrofncode);
            var macrofn = evalJavascript(macrofncode);
            if(macrofn) {
              // adding macro into the keywords for the current dialect
// REVISIT THIS LINE - WHAT ABOUT LOCAL DIALECTS?  THIS IS JUST THE CURRENT FILE DIALECT:
              source.dialects[0].keywords[mName.value] = macrofn;
            }
            else {
              form.error("malformed macro function: could not generate macro function");
            }

            // making the named macro available to the rest of the transpile
            // was all that's needed in this case.
            trace("Returning nothing in generated output (" + sl.valueOf(mName) + " was eval'ed)");
            ctx.noSemiColon = true;
            ctx.noNewline = true;
            var noout = sl.transpiled();
            noout.__compiletimemacro = true;
            return noout;
          }

          // Did we get back forms (i.e. was it a macro or a function playing
          // the role of macro?)
          if(!sl.isTranspiled(result) &&
            !options.expandOnly && !ctx.options.transpile.noMacros)
          {
            // transpile these forms - we need code!!
            return transpileExpression(result);
          }
          else {
            // it's ready for output
            return result;
          }
        }

        // transform e.g. (.method target) to (target).method
        if (command.charAt(0) === ".") {
            //NOT SURE THIS IS STILL NEEDED - NEED TO CONFIRM
            //console.log("IS THIS STILL USED?")
            var transpiled = sl.transpiled();
            transpiled.push(Array.isArray(form[1]) ? transpileExpression(form[1]) : form[1]);
            transpiled.unshift("(");
            transpiled.push([")", form[0]]);

            return transpiled
        }
    }
    // the thing in first position was not a known function or macro...
    if(typeof options.passthru !== 'undefined' && !options.passthru) {
      return null;
    }

    // is it a new "top level" e.g. an inline script tag?
    if(form.__toplevel) {
      return transpileExpressions(form);
    }
    // or it may be a "passthru"
    // (things not in the keyword tables simply "pass through" to the output)
    transpileSubExpressions(form);
    var firstCodeForm = form[0];
    if(!firstCodeForm) {
      return sl.transpiled();
    }

    // it's most likely a function to call...
    var fName = firstCodeForm;

    // but if it's a list not an atom...
    if (sl.isTranspiled(firstCodeForm)) {
      // if it's not the keyword "function"
      if(!isFunction.test(firstCodeForm.toString())) {
// I THINK I GOT A LITTLE CONFUSED BELOW - THIS IS looking
// AT THE TRANSPILED OUTPUT NOT THE READ *FORMS*.  although
// THIS IS THE CASE WHERE THINGS ARE "PASSING THRU" TO THE
// OUTPUT SO THERE IS A CORRESPONDANCE BETWEEN THE input
// FORMS AND THE TRANSPILED FORMS IN THIS CASE.
//
// I ADDED THIS CHECK BELOW TO GET MY gox.scripty csp EXAMPLE
// TO WORK - BUT IT'S A HACK!! I THINK I *CANT* TELL WHEN
// PARENS HAVE BEEN ADDED TO CONTROL PRECEDENCE VERSUS
// NORMAL USE OF LISPY PARENS!  THE LINE BELOW WAS A HACK
// TO SAY THINGS LIKE "csp.go" ARE NOT PARENTHESIZED FOR
// THE SAKE OF CONTROLLING PRECEDENCE WHEREAS (x = getit()) !== true
// IS.  MAYBE I NEED A WAY TO MARK ARRAYS WHERE THE *USER* ENTERED
// ACTUAL PARENS VERSUS WHERE THE ARRAYS REPRESENT E.G. NESTED
// STRUCTURE INFERRED BY SCRIPTY WITH ITS "NOPARENS" APPROACHES.
// AND MAYBE IN SCRIPTY WE REALLY AND TRULY SAY THAT PARENS ARE
// *NOT* LISPY PARENS.  PARENS ARE EITHER EXPECTED SYNTAX
// (EG AROUND CONDITIONS IN IFS AND WHILES) OR ELSE THEY ARE
// THE USER ADDING THEM TO OVERRIDE PRECEDENCE.   WHEREAS IN
// LISPY OBVIOUSLY PARENS ARE NORMAL LISPY PARENS.
//
// THE COUNTERPOINT IS THAT THIS IS THE *SAME* TRANSPILER FOR
// BOTH SCRIPTY AND LISPY - THERE'S ONLY ONE!! SO *IF* "EXTRA"
// PARENS ARE ALLOWED IN SCRIPTY THAT MEANS THEY'RE ALSO POSSIBLE
// IN LISPY!!  BUT WHAT DO *EXTRA* PARENS MEAN IN LISPY?  THEY
// WOULD TRADITIONALLY HAVE BEEN AN ERROR RIGHT?  IE IN LISPY
// EXTRA PARENS WOULD NORMALLY MEAN AN ARRAY THAT DOESNT HAVE
// A FUNCTION/MACRO TO CALL IN FIRST POSITION - IT HAS AN ARRAY
// IN FIRST POSITION!  CAN THIS RECONCILED WITH SCRIPTY IN A
// LOGICAL/UNDERSTANDABLE WAY?  WHAT WOULD THE RULES BE that
// MAKES IT UNDERSTANDABLE?
//
// NEEDS MORE THOUGHT AND EXPERIMENTATION - BUT NOT RIGHT NOW!!
        var frst = firstCodeForm[0];
        // NEW TRY if(frst && Array.isArray(frst) && frst.length > 0 && sl.valueOf(frst[1]) !== '.') {
        if(Array.isArray(frst) && frst.length > 0 && sl.valueOf(frst[1]) !== '.') {
          // this is not a function call it's just a
          // a form parenthesized to override default precedence
          form[0] = sl.transpiled(['(', firstCodeForm, ')']);
          return form;
        }
      }
      else {
        // this is an inline function to be called
        // it must be wrapped in () as an IIFE
        fName = sl.transpiled(['(', fName, ')'])
      }
    }

    // is this an extra wrapper?
    // (can happen e.g. if they parenthesize infix expressions in sugarscript)
    if(Array.isArray(form) && form.length === 1 &&
       (typeof form[0].callable !== 'undefined' && !form[0].callable))
    {
      return form[0]; // unwrap so don't get e.g. (x == y)() !!
    }

    // this is a function call - generate in javascript "fn(args)" style
    var fArgs = sl.transpiledFromArray(form.slice(1)).join(",");
    var fCall = sl.transpiled(fName,
                        sl.atom("(", {token: form}),
                        fArgs,
                        sl.atom(")", {token: form, tokenType: "end"}));
    if(fName.prelude) {
      fCall.unshift([sanitizePrelude(fName.prelude)]);
    }

    return fCall;
}

function includeBindingCode(when, form, codearray) {
  if(form.length > 1 && form[0].value && form[1].value) {
    var fnName = form[0].value;
    var firstArg = form[1].value;
    var source = sl.sourceOf(form);
    if(source && source.bindingCode[when][fnName]) {
      source.bindingCode[when][fnName].forEach(function(injectspec) {
        injectspec.of.forEach(function(observed) {
          if(sl.valueOf(observed) === firstArg) {
            trace("including " + when + " " + fnName + " binding code: " + injectspec.insert.toString());
            codearray.push(injectspec.insert);
          }
        });
      });
    }
  }
  return codearray;
}

// transpileExpression shorthand:
//    infer whether the given expression needs to be transpiled or not
var x = function(form, options) {
  if(form && !sl.isAtom(form) && sl.isList(form) && form.length > 0) {
      return transpileExpression(form, options);
  }
  else {
    if(Array.isArray(form)) {
      transpileSubExpressions(form, options);
    }
  }

  return form;
}

// transpileSubExpressions transpiles the children of the array and
// replaces them with their transpiled output.  It does not return anything.
var transpileSubExpressions = function(forms) {
    forms.forEach(function(value, formPos, forms) {
        if (Array.isArray(value)) forms[formPos] = transpileExpression(value)
    })
}

/**
* eval the js code generated from the provided expression forms
*/
var evalExpression = function (form) {
  var code = transpileExpression(form);
  return evalJavascript(code.toString());
}

/**
* eval the provide javascript code using vm.runInThisContext if
* the "csp" transpile option was provided (otherwise normal eval).
*/
var evalJavascript = function (jscodestr) {
  var result;

  // we make the transpiler options visible to the eval
  var transpile = ctx.options.transpile;
  jscodestr = "(" + jscodestr + ")";

  // allow eval to work without error when CSP e.g. in Atom Preview
  if(ctx.options.transpile.csp) {
    require('loophole').allowUnsafeEval(function() {
      result = eval(jscodestr);
    });
  }
  else {
    result = eval(jscodestr);
  }

  return result;
}

// expand a macro expression (without fully compiling it)
var expandExpression = function(form) {
  // truncate compilation after expanding the macro
  return transpileExpression(form, true);
}

// transpile the source of the specified file to a string containing
// the generated code
// (this is the main entry point for the sugarlisp transpiler)
// options =
//   sourceMap: true to generate source maps
//   to: 'core' or 'json' (otherwise to javascript!)
var transpile = function(codestr, filename, options) {
  debug('***** STARTING FILE:', filename);

  // switch false to true below for a quick and dirty profile of timings
  var dumptimes = false && (console.time && console.timeEnd);
  if(dumptimes) { console.time("total"); }

  // make transpiler options, filename, etc. visible to the template functions:
  ctx.options = { transpile: (options || {}) };
  ctx.options.transpile.on = (typeof window === 'undefined' ? "server" : "browser");
  ctx.filename = filename;
  ctx.fileext = path.extname(filename);
  ctx.indent = -ctx.indentSize;

  if (typeof ctx.options.transpile.includeComments === 'undefined') {
    ctx.options.transpile.includeComments = false;
  }

  // read the lispy forms from this source file (as well as any dialects it #uses)
  debug('\n** READING\n');
  if(dumptimes) { console.time("read"); }
  var forms = reader.read_from_source(codestr, filename, ctx.options.transpile);

  if(ctx.options.transpile.unwrapTopForm && Array.isArray(forms)) {
    // there are "nop" (noop) forms at the start left from the #uses:
    forms = forms[forms.length-1];
  }

  if(dumptimes) { console.timeEnd("read"); }
  debug('\n** THE FORMS READ WERE:\n' + sl.pprintSEXP(forms.toJSON(),{bareSymbols: true}));

  if(ctx.options.transpile.to === 'core') {
    // they want the parse tree formatted back as s-expreesions
    return sl.pprintSEXP(forms.toJSON(),{bareSymbols: true}) + '\n';
    // if they want as JSON the above becomes: return JSON.stringify(forms.toJSON()) + '\n'
  }
  else if(ctx.options.transpile.to === 'json') {
    // they just want the parse tree as json
    return sl.pprintJSON(forms.toJSON(),{bareSymbols: false}) + '\n';
    // if they want as JSON the above becomes: return JSON.stringify(forms.toJSON()) + '\n'
  }
  debug('\n** TRANSPILING\n');
  if(dumptimes) { console.time("transpile"); }
  var transpiled = transpileExpressions(forms)
  if(bannerables.indexOf(ctx.fileext) !== -1) {
    transpiled.unshift(banner);
  }
  if(dumptimes) { console.timeEnd("transpile"); }

  // generate source maps if requested
  // note:  we do not support source map generation when compiling in browser.
  if (ctx.options.transpile.sourceMap) {
// SHOULDN'T THE OUTPUT FILE NAME BE PASSED INTO US AS AN OPTION?
    var outputFilename = path.basename(filename, path.extname(filename)) + '.js';

    // Create the source map using mozilla's library
    var output = toStringWithSourceMap(transpiled, filename, outputFilename);
    var sourceMapFile = outputFilename + '.map';
    fs.writeFileSync(sourceMapFile, output.map)

    // note we return the code generated by the mozilla library
    // (so we're ensured it matches the source map)
    return output.code + "\n//# sourceMappingURL=" +
            path.relative(path.dirname(filename),
            sourceMapFile);
  }

  var result = transpiled.toString();

  // running this third party beautifier is just a stop gap till some
  // formatting bugs are fixed - note we only do this when compiling with
  // node, we don't do (or support) this in the browser (for both
  // performance and code size reasons).
  if(typeof ctx.options.transpile.pretty === 'undefined' ||
    (typeof ctx.options.transpile.pretty === 'boolean' &&
      ctx.options.transpile.pretty !== false) ||
    (typeof ctx.options.transpile.pretty === 'string' &&
      ['false','no'].indexOf(ctx.options.transpile.pretty) === -1))
  {
    if(dumptimes) { console.time("beautify"); }
    result = beautify(result, { indent_size: 2 });
    if(dumptimes) { console.timeEnd("beautify"); }
  }

  if(dumptimes) { console.timeEnd("total"); }
  return result;
}

function toStringWithSourceMap(transpiled, inputFilename, outputFilename) {
  // fill in missing line/col numbers
  setMissingLineColNumbers(transpiled);

  // convert our transpiled tree to a Mozilla SourceNode tree
  var sourceNodes = toSourceNodes(transpiled, inputFilename);

  return sourceNodes.toStringWithSourceMap({
    file: outputFilename
  });
}

function setMissingLineColNumbers(transpiled) {
  var lastLine = 0, lastCol = 0;
  sl.finddeep(transpiled, function(form, pos) {
    if(typeof form.line !== 'undefined' && typeof form.col !== 'undefined') {
      lastLine = form.line;
      lastCol = form.col;
    }
    else {
      form.line = lastLine;
      form.col = lastCol;
    }
    return false; // (keep walking)
  });
}

function toSourceNodes(transpiled, inputFilename) {
  var SourceNode = require('source-map').SourceNode;
  var rootNode = new SourceNode();
  var lastLine = 0, lastCol = 0;
  sl.finddeep(transpiled, function(form, pos) {
    var text = sl.toString(form);
    // account for the 2 line wrapper,
    // plus lines start at 1, columns start at 0
    var node = new SourceNode(form.line >= 1 ? form.line : 1, form.col, inputFilename, text, text);
    rootNode.add(node);
    return false; // (keep walking)
  });

  return rootNode;
}


/**
* Find the most recently closest scoped dialect with a keyword function
* (macro or code generator) with the specified name and execute it.
*/
function execKeywordFnFor(command, form) {
  // the transpile functions can generate code or
  // just rearrange the forms as a macro
  var result;
  var closestDialect = getDialectFor(form);
  if(closestDialect.keywords && closestDialect.keywords[command]) {
    var keywordfns = Array.isArray(closestDialect.keywords[command]) ?
          closestDialect.keywords[command] : [closestDialect.keywords[command]];
    keywordfns.find(function(keywordfn) {

      // Give them a simple error reporter that will
      // by default use line/col info from this expression (form)
      ctx.error = function(msg, locator) {
        form.error(msg, locator);
      };

      // invoke the transpile function where "this" gives them
      // their "context"...

      debug("invoking " + (command === "macro" ? "macro " : "") +
        'function "' + command + '" in "' + closestDialect.__dialectname + '"' +
          (keywordfn.__dialectname &&
            closestDialect.__dialectname != keywordfn.__dialectname ?
              ' (inherited from "' + keywordfn.__dialectname + '")' : ""));

      // was the function coded to expect arguments?
      if(/^function\s*\w*\(\s*\)/.exec(keywordfn.toString())) {
        // nope - spread the args (as expected by a match function)
        result = keywordfn.apply(ctx, form);
      }
      else {
        // yup presumably they're expecting the "forms" array
        result = keywordfn.call(ctx, form);
      }

      // the keyword function can return undefined to defer to other dialects
      return(typeof result !== 'undefined');
    });
  }
  else {
    debug('No keyword function in "' + closestDialect.__dialectname +
                  '" for "' + command + '" (pass thru to generated code)');
  }

  return result;
}

function getDialectFor(form) {
  var currDialect = reader.get_closest_scoped_dialect_for(form);
  if(!currDialect) {
    // no dialect on the form (or it's parents)...
    // use the last #used file level dialect
    var source = sl.sourceOf(form);
    currDialect = source.dialects[0];
  }
  return currDialect;
}

utils.mergeInto(ctx, {
  transpile: transpile,
  x: x,
  transpileExpressions: transpileExpressions,
  transpileExpression: transpileExpression,
  transpileSubExpressions: transpileSubExpressions,
  expandExpression: expandExpression,
  macroexpand: macros.expand,
  evalExpression: evalExpression,
  evalJavascript: evalJavascript
});

module.exports = {
  transpile: transpile,
  transpileExpression: transpileExpression,
  transpileExpressions: transpileExpressions
};
