var packageJson = require('../package.json'),
    banner = "// Generated by SugarLisp v" + packageJson.version + "\n",
    bannerables = ['.slisp', '.ls', '.sugar'],
    isFunction = /^function\b/,
    returnStmtIllegalCode = /^[\s]*return\b|^[\s]*if\b|^[\s]*for\b|^[\s]*while\b|^[\s]*switch\b|^[\s]*break\b|^[\s]*console\b/,
    sl = require('sugarlisp-core/sl-types'),
    dialoader = require("sugarlisp-core/dialect-loader"), // avoid circular dependency (need to investigate)
    macros = require('sugarlisp-core/macro-expander'),
    lex = require('sugarlisp-core/lexer'),
    reader = require('sugarlisp-core/reader'),
    handlers = require('./handler-utils'),
    utils = require('sugarlisp-core/utils'),
    ctx = require('sugarlisp-core/transpiler-context'),
    beautify = require('js-beautify').js_beautify;

var debug = require('debug')('sugarlisp:transpiler:debug'),
    trace = require('debug')('sugarlisp:transpiler:trace'),
    //slinfo = function() { console.log.apply(this, arguments); };
    slinfo = require('debug')('sugarlisp:info');

/**
* transpile the source of the specified file to a string containing
* the generated code
* (this is the main entry point for the sugarlisp transpiler)
* options =
*   sourceMap: true to generate source maps
*   to: 'tokens' or 'core' or 'json' (otherwise to javascript!)
*/
var transpile = function(codestr, filenameOrLexer, options) {

  var lexer;
  var filename;
  if(filenameOrLexer instanceof lex.Lexer) {
     lexer = filenameOrLexer;
     filename = lexer.filename;
  }
  else {
    filename = filenameOrLexer;
  }

  debug('***** STARTING FILE:', filename);

  // switch false to true below for a quick and dirty profile of timings
  var dumptimes = false && (console.time && console.timeEnd);
  if(dumptimes) { console.time("total"); }

  ctx.initialize(filename, options);

  if (typeof ctx.options.transpile.includeComments === 'undefined') {
    ctx.options.transpile.includeComments = false;
  }

  // do they want a dump of the tokens (presumably for debugging purposes?)
  // note: these are an *approximate* dump of tokens available if the
  //   (more accurate) "tokens" option is failing.
  if(ctx.options.transpile.to === '~tokens') {
    var tokens = reader.nonlocal_tokens(codestr, filename);
    return lex.formatTokenDump(tokens, lex.formatTokenText);
  }
  if(ctx.options.transpile.to === '~tokensx') {
    var tokens = reader.nonlocal_tokens(codestr, filename);
    return lex.formatTokenDump(tokens, lex.formatTokenSexp, "(tokens ", ")");
  }

  // read the lispy forms from this source file (as well as any dialects it #uses)
  debug('\n** READING\n');
  if(dumptimes) { console.time("read"); }
  var forms = reader.read_from_source(codestr,
                        (lexer ? lexer : filename),
                        ctx.options.transpile);

  if(Array.isArray(forms)) {
    if(ctx.options.transpile.unwrapTopForm ||
      (typeof ctx.options.transpile.unwrapTopForm === 'undefined' &&
        (ctx.options.transpile.to === 'core' || ctx.options.transpile.to === 'json') &&
        ctx.options.transpile.wrapOuterForm !== 'no'))
    {
      // there are "nop" (noop) forms at the start left from the #uses:
      forms = forms[forms.length-1];
    }
  }

  if(dumptimes) { console.timeEnd("read"); }
  debug('\n** THE FORMS READ WERE:\n' + sl.pprintSEXP(forms.toJSON(),{bareSymbols: true}));

  if(ctx.options.transpile.to === 'core') {
    // they want the parse tree formatted back as s-expreesions
    return sl.pprintSEXP(forms.toJSON(),{bareSymbols: true}) + '\n';
  }
  else if(ctx.options.transpile.to === 'json') {
    // they just want the parse tree as json
    return sl.pprintJSON(forms.toJSON(),{bareSymbols: false}) + '\n';
  }

  // do they want an *accurate* dump of the tokens?
  // because of the "--to tokens" option, the lexer used by read_from_source
  // has kept a dump of the tokens.  This is the only way to ensure we
  // match when e.g. local dialects have their own lextabs.  Unfortunately
  // this isn't much help if reading is blowing up - so there's is also
  // the "~tokens" ("approximate tokens") option (see above).
  if(ctx.options.transpile.to === 'tokens') {
    return lex.formatTokenDump(ctx.lexer.tokenDump, lex.formatTokenText);
  }
  if(ctx.options.transpile.to === 'tokensx') {
    return lex.formatTokenDump(ctx.lexer.tokenDump, lex.formatTokenSexp, "(tokens ", ")");
  }

  // if we reach here they really *do* want to transpile...

  debug('\n** TRANSPILING\n');
  if(dumptimes) { console.time("transpile"); }
  var generated = transpileExpressions(forms)
  if(bannerables.indexOf(ctx.fileext) !== -1) {
    generated.unshift(banner);
  }
  if(dumptimes) { console.timeEnd("transpile"); }

  // generate source maps if requested
  // note:  we do not support source map generation when compiling in browser.
  if (ctx.options.transpile.sourceMap) {
// SHOULDN'T THE OUTPUT FILE NAME BE PASSED INTO US AS AN OPTION?
    var outputFilename = path.basename(filename, path.extname(filename)) + '.js';

    // Create the source map using mozilla's library
    var output = toStringWithSourceMap(generated, filename, outputFilename);
    var sourceMapFile = outputFilename + '.map';
    fs.writeFileSync(sourceMapFile, output.map)

    // note we return the code generated by the mozilla library
    // (so we're ensured it matches the source map)
    return output.code + "\n//# sourceMappingURL=" +
            path.relative(path.dirname(filename),
            sourceMapFile);
  }

  var result = generated.toString();

  // running this third party beautifier is just a stop gap till some
  // formatting bugs are fixed - note we only do this when compiling with
  // node, we don't do (or support) this in the browser (for both
  // performance and code size reasons).
  if(typeof ctx.options.transpile.pretty === 'undefined' ||
    (typeof ctx.options.transpile.pretty === 'boolean' &&
      ctx.options.transpile.pretty !== false) ||
    (typeof ctx.options.transpile.pretty === 'string' &&
      ['false','no'].indexOf(ctx.options.transpile.pretty) === -1))
  {
    if(dumptimes) { console.time("beautify"); }
    result = beautify(result, { indent_size: 2 });
    if(dumptimes) { console.timeEnd("beautify"); }
  }

  if(dumptimes) { console.timeEnd("total"); }
  return result;
}

function sanitizePrelude(prelude) {

  // we add a newline ourselves - so reduce 2 in the prelude to one:
  var sanitized = prelude.replace(/^\n/, '');
  //sanitized = sanitized.replace(/\n$/, '');
  // convert lispy line comments (";;" and ";") to javascript's "//"
  sanitized = sanitized.replace(/\;\;/g, '//').replace(/\;/g, '//');

  if(!ctx.options.transpile.includeComments && !sanitized.match(/^\s+$/)) {
    return "";
  }

  return sanitized;
}

var transpileExpressions = function(forms, noReturnStmt) {
    ctx.indent += ctx.indentSize;
    var generated = sl.generated(),
        indentstr = " ".repeat(ctx.indent);

    // a prelude on the top forms may be e.g.
    // comments from the top of a file.
    if(forms.prelude) {
      generated.push([sanitizePrelude(forms.prelude)]);
    }

    forms.forEach(function(form, formPos, forms) {
        var nextForm = null;

        if (Array.isArray(form)) {
            nextForm = transpileExpression(form)
        } else {
            nextForm = form
        }

        if (nextForm) {
            var nextFormStr = nextForm.toString();
            var nextFormStrTrimmed = nextFormStr.trim();

            // note: originally it was the "context" that held the "noSemiColon"
            //   flag but that has been a problem - want to move to the generated
            //   list's *forms* having that directly (which is more controlled)
            var endline = (nextForm.noSemiColon || ctx.noSemiColon ? "" :
              // avoid double semicolons regardless
              (nextFormStrTrimmed.charAt(nextFormStrTrimmed.length-1) === ';' ? "" : ";"));
            ctx.noSemiColon = false;
            endline += (nextForm.noNewline || ctx.noNewline ? "" :
              // avoid double newlines
              (nextFormStr.charAt(nextFormStr.length-1) === '\n' ? "" : "\n"));
            ctx.noNewline = false;

            // eliminate extra returns from compile macros
            if(nextForm.prelude && !nextForm.__compiletimemacro) {
              generated.push([sanitizePrelude(nextForm.prelude)]);
            }

            // we (typically) add a return on the last expression for
            // all but the topmost expressions (i.e. topmost in a file)
            var optionalReturnStmt = "";
            if (!noReturnStmt && formPos === forms.length-1 && ctx.indent) {
                // but not always:
                if((typeof ctx.options.transpile.implicitReturns === 'undefined' ||
                  ctx.options.transpile.implicitReturns) &&
                  !(nextForm.noReturn || ctx.noReturn) &&
                    !returnStmtIllegalCode.test(nextFormStr))
                {
                  optionalReturnStmt = "return ";
                }
                ctx.noReturn = false;
            }

            if(!reader.isignorableform(nextForm)) {
              // note we push *nextForm* not *nextFormStr* to preserve line/cols
              generated.push([indentstr + optionalReturnStmt, nextForm, endline]);
            }

            if(nextForm.endPrelude) {
               generated.push([sanitizePrelude(nextForm.endPrelude)]);
            }
        }

        // output any before/after code
        // (most likely the result of binding expressions e.g. the "#=")
        if(ctx.beforeCode && ctx.beforeCode.length > 0) {
          ctx.beforeCode.forEach(function(beforecode) {
            generated.unshift([ctx.margin(),beforecode.toString(),"\n"]);
          });
          ctx.beforeCode = [];
        }
        if(ctx.afterCode && ctx.afterCode.length > 0) {
          ctx.afterCode.forEach(function(aftercode) {
            generated.push([ctx.margin(),aftercode.toString(),"\n"]);
          });
          ctx.afterCode = [];
        }
    })

    // an endPrelude at the top level may be
    // e.g. comments at the end of a file
    if(forms.endPrelude) {
      generated.push([sanitizePrelude(forms.endPrelude)]);
    }
    ctx.indent -= ctx.indentSize;
    return generated;
}

// transpileExpression returns a generated expression
// with any prelude (leading whitespace or comments)
// prepended so they pass thru to the generated code
var transpileExpression = function(form, options) {

  var generated = transpileExpressionAlone(form, options);
  if(generated) {
    // a prelude is comments or white space preceding a form
    generated.prelude = generated.prelude || form.prelude ||
      (Array.isArray(form) && form.length > 0 ? form[0].prelude : undefined);

    // an end prelude is comments or white space preceding
    // the end of a list
    generated.endPrelude = generated.endPrelude || form.endPrelude ||
      (Array.isArray(form) && form.length > 0 ? form[0].endPrelude : undefined);
  }

  // now that this expression is completely generated
  if (Array.isArray(form)) {
    // find binding code to be included before/after this expression
    // (this is our approach to automatically invoking "reactor" functions)
    ctx.beforeCode = includeBindingCode("before", form, ctx.beforeCode);
    ctx.afterCode = includeBindingCode("after", form, ctx.afterCode);
  }

  return generated;
}

// transpileExpressionAlone is a helper for transpileExpression above
// (call it instead)
var transpileExpressionAlone = function(form, options) {

    if (!form || !form[0]) {
        return null;
    }

    options = options || {};
    var lexer = sl.lexerOf(form);
    var command = sl.valueOf(form[0]);
    slinfo("command: " + command);

    if(command) {
      var msg = 'looking up gentab function for "' + command + '"';
      debug(lexer.message_src_loc(msg, form[0], {file:false}));
    }
    else {
      debug('command without a symbol in first position!!',
        typeof form[0], "array:", Array.isArray(form[0]));
    }

    if (typeof command === "string") {
        // accept javascript strings as return values from gentab functions
        // note: they typically return sl.generated() objects, returning strings
        //   is the exception not the rule.
        var result = handlers.callHandlerfnFor(command, form);
        if(result && typeof result === "string") {
          var snode = sl.generated();
          snode.push(result);
          result = snode;
        }
        if(result) {
          // is this a compile time macro function e.g. a (macro name ...)
          // form or a function prefixed by #keyword?
          if(form.__macrofn || result.__macrofn) {
            registerMacro(form, result.toString());
            var noout = sl.generated();
            noout.__compiletimemacro = true;
            return noout;
          }

          // Did we get back forms (i.e. was it a macro or a function playing
          // the role of macro?)
          if(!sl.isGenerated(result) &&
            !options.expandOnly && !ctx.options.transpile.noMacros)
          {
            // transpile these forms - we need code!!
            return transpileExpression(result);
          }
          else {
            // it's ready for output
            return result;
          }
        }

        // transform e.g. (.method target) to (target).method
        if (command.charAt(0) === ".") {
            //NOT SURE THIS IS STILL NEEDED - NEED TO CONFIRM
console.log("IS THIS STILL USED?")
            var generated = sl.generated();
            generated.push(Array.isArray(form[1]) ? transpileExpression(form[1]) : form[1]);
            generated.unshift("(");
            generated.push([")", form[0]]);

            return generated
        }
    }

    return transpileOther(form, options);
}

// Transpile the forms that are not found in the gentab,
// e.g. forms that simply pass thru to the output, etc.
function transpileOther(form, options) {

  // the thing in first position was not a known function or macro...
  if(typeof options.passthru !== 'undefined' && !options.passthru) {
    return null;
  }

  // is it a new "top level" e.g. an inline script tag?
  if(form.__toplevel) {
    return transpileExpressions(form);
  }
  // or it may be a "passthru"
  // (things not in the gentab tables simply "pass through" to the output)
  transpileSubExpressions(form);
  var firstCodeForm = form[0];
  if(!firstCodeForm) {
    return sl.generated();
  }

  // it's most likely a function to call...
  var fName = firstCodeForm;

  // but if it's a list not an atom...
  if (sl.isGenerated(firstCodeForm)) {
    // if it's not the keyword "function"
    if(!isFunction.test(firstCodeForm.toString())) {
// I THINK I GOT A LITTLE CONFUSED BELOW - THIS IS looking
// AT THE TRANSPILED OUTPUT NOT THE READ *FORMS*.  although
// THIS IS THE CASE WHERE THINGS ARE "PASSING THRU" TO THE
// OUTPUT SO THERE IS A CORRESPONDANCE BETWEEN THE input
// FORMS AND THE TRANSPILED FORMS IN THIS CASE.
//
// I ADDED THIS CHECK BELOW TO GET MY gox.scripty csp EXAMPLE
// TO WORK - BUT IT'S A HACK!! I THINK I *CANT* TELL WHEN
// PARENS HAVE BEEN ADDED TO CONTROL PRECEDENCE VERSUS
// NORMAL USE OF LISPY PARENS!  THE LINE BELOW WAS A HACK
// TO SAY THINGS LIKE "csp.go" ARE NOT PARENTHESIZED FOR
// THE SAKE OF CONTROLLING PRECEDENCE WHEREAS (x = getit()) !== true
// IS.  MAYBE I NEED A WAY TO MARK ARRAYS WHERE THE *USER* ENTERED
// ACTUAL PARENS VERSUS WHERE THE ARRAYS REPRESENT E.G. NESTED
// STRUCTURE INFERRED BY SCRIPTY WITH ITS "NOPARENS" APPROACHES.
// AND MAYBE IN SCRIPTY WE REALLY AND TRULY SAY THAT PARENS ARE
// *NOT* LISPY PARENS.  PARENS ARE EITHER EXPECTED SYNTAX
// (EG AROUND CONDITIONS IN IFS AND WHILES) OR ELSE THEY ARE
// THE USER ADDING THEM TO OVERRIDE PRECEDENCE.   WHEREAS IN
// LISPY OBVIOUSLY PARENS ARE NORMAL LISPY PARENS.
//
// THE COUNTERPOINT IS THAT THIS IS THE *SAME* TRANSPILER FOR
// BOTH SCRIPTY AND LISPY - THERE'S ONLY ONE!! SO *IF* "EXTRA"
// PARENS ARE ALLOWED IN SCRIPTY THAT MEANS THEY'RE ALSO POSSIBLE
// IN LISPY!!  BUT WHAT DO *EXTRA* PARENS MEAN IN LISPY?  THEY
// WOULD TRADITIONALLY HAVE BEEN AN ERROR RIGHT?  IE IN LISPY
// EXTRA PARENS WOULD NORMALLY MEAN AN ARRAY THAT DOESNT HAVE
// A FUNCTION/MACRO TO CALL IN FIRST POSITION - IT HAS AN ARRAY
// IN FIRST POSITION!  CAN THIS RECONCILED WITH SCRIPTY IN A
// LOGICAL/UNDERSTANDABLE WAY?  WHAT WOULD THE RULES BE that
// MAKES IT UNDERSTANDABLE?
//
// NEEDS MORE THOUGHT AND EXPERIMENTATION - BUT NOT RIGHT NOW!!
      var frst = firstCodeForm[0];
      // NEW TRY if(frst && Array.isArray(frst) && frst.length > 0 && sl.valueOf(frst[1]) !== '.') {
      if(Array.isArray(frst) && frst.length > 0 && sl.valueOf(frst[1]) !== '.') {
        // this is not a function call it's just a
        // a form parenthesized to override default precedence
        form[0] = sl.generated(['(', firstCodeForm, ')']);
        return form;
      }
    }
    else {
      // this is an inline function to be called
      // it must be wrapped in () as an IIFE
      fName = sl.generated(['(', fName, ')'])
    }
  }

  // is this an extra wrapper?
  // (can happen e.g. if they parenthesize infix expressions in sugarscript)
  if(Array.isArray(form) && form.length === 1 &&
     (typeof form[0].callable !== 'undefined' && !form[0].callable))
  {
    return form[0]; // unwrap so don't get e.g. (x == y)() !!
  }

  // this is a function call - generate in javascript "fn(args)" style
  var fArgs = sl.generatedFromArray(form.slice(1)).join(",");
  var fCall = sl.generated(fName,
                      sl.atom("(", {token: form}),
                      fArgs,
                      sl.atom(")", {token: form, tokenType: "end"}));
  if(fName.prelude) {
    fCall.unshift([sanitizePrelude(fName.prelude)]);
  }

  return fCall;
}

function includeBindingCode(when, form, codearray) {
  if(form.length > 1 && form[0].value && form[1].value) {
    var fnName = form[0].value;
    var firstArg = form[1].value;
    var lexer = sl.lexerOf(form);
    if(lexer && lexer.bindingCode[when][fnName]) {
      lexer.bindingCode[when][fnName].forEach(function(injectspec) {
        injectspec.of.forEach(function(observed) {
          if(sl.valueOf(observed) === firstArg) {
            trace("including " + when + " " + fnName + " binding code: " + injectspec.insert.toString());
            codearray.push(injectspec.insert);
          }
        });
      });
    }
  }
  return codearray;
}

// transpileExpression shorthand:
//    infer whether the given expression needs to be generated or not
var x = function(form, options) {
  if(form && !sl.isAtom(form) && sl.isList(form) && form.length > 0) {
      return transpileExpression(form, options);
  }
  else {
    if(Array.isArray(form)) {
      transpileSubExpressions(form, options);
    }
  }

  return form;
}

/**
* transpileSubExpressions transpiles the children of the array and
* replaces them with their generated output.  It does not return anything.
*/
var transpileSubExpressions = function(forms) {
    forms.forEach(function(value, formPos, forms) {
        if (Array.isArray(value)) forms[formPos] = transpileExpression(value)
    })
}

/**
* Transpile the forms in the provided list and return them as
* a code for a comma separated argument list.
*/
var transpileArgList = function(forms) {
  transpileSubExpressions(forms);
  return sl.generatedFromArray(forms).join(",");
}

var transpileCommaExpression = function(forms) {
  var commasepexpr;
  if(sl.isAtom(forms)) {
    commasepexpr = sl.generated(sl.valueOf(forms));
  }
  else {
    if(forms[0].value === "begin") {
      forms.shift();

      if(forms.length === 1 && sl.isAtom(forms[0])) {
        commasepexpr = sl.generated(sl.valueOf(forms[0]));
      }
      else {
        transpileSubExpressions(forms);
        commasepexpr = sl.generated(['(', sl.generatedFromArray(forms).join(","), ')']);
      }
    }
    else {
      commasepexpr = transpileExpression(forms);  
    }
  }
  return commasepexpr;
}

/**
* eval the js code generated from the provided expression forms
*/
var evalExpression = function (form) {
  var code = transpileExpression(form);
  return handlers.evalJavascript(code.toString());
}

// expand a macro expression (without fully compiling it)
var expandExpression = function(form) {
  // truncate compilation after expanding the macro
  return transpileExpression(form, true);
}

function toStringWithSourceMap(generated, inputFilename, outputFilename) {
  // fill in missing line/col numbers
  setMissingLineColNumbers(generated);

  // convert our generated tree to a Mozilla SourceNode tree
  var sourceNodes = toSourceNodes(generated, inputFilename);

  return sourceNodes.toStringWithSourceMap({
    file: outputFilename
  });
}

function setMissingLineColNumbers(generated) {
  var lastLine = 0, lastCol = 0;
  sl.finddeep(generated, function(form, pos) {
    if(typeof form.line !== 'undefined' && typeof form.col !== 'undefined') {
      lastLine = form.line;
      lastCol = form.col;
    }
    else {
      form.line = lastLine;
      form.col = lastCol;
    }
    return false; // (keep walking)
  });
}

function toSourceNodes(generated, inputFilename) {
  var SourceNode = require('source-map').SourceNode;
  var rootNode = new SourceNode();
  var lastLine = 0, lastCol = 0;
  sl.finddeep(generated, function(form, pos) {
    var text = sl.toString(form);
    // account for the 2 line wrapper,
    // plus lines start at 1, columns start at 0
    var node = new SourceNode(form.line >= 1 ? form.line : 1, form.col, inputFilename, text, text);
    rootNode.add(node);
    return false; // (keep walking)
  });

  return rootNode;
}

function registerMacro(form, macrofncode) {
  var mName;
  if(!sl.isList(form[1]) && sl.isList(form[2])) {
      mName = form[1];
  }
  else {
    form.error("compile time macro functions must have a name.");
  }
  debug("registering compile time macro function:", sl.valueOf(mName));
  // eval the javascript generated for the macro function
  trace("the macro function code is:", macrofncode);
  var macrofn = handlers.evalJavascript(macrofncode);
  if(macrofn) {
    // adding macro into the transpile table for the current dialect
// REVISIT THIS LINE - WHAT ABOUT LOCAL DIALECTS?  THIS IS JUST THE CURRENT FILE DIALECT:
    sl.lexerOf(form).dialects[0].gentab[mName.value] = macrofn;
  }
  else {
    form.error("malformed macro function: could not generate macro function");
  }

  // making the named macro available to the rest of the transpile
  // was all that's needed in this case.
  trace("Returning nothing in generated output (" + sl.valueOf(mName) + " was eval'ed)");
  ctx.noSemiColon = true;
  ctx.noNewline = true;
}

utils.mergeInto(ctx, {
  transpile: transpile,
  x: x,
  transpileExpressions: transpileExpressions,
  transpileExpression: transpileExpression,
  transpileSubExpressions: transpileSubExpressions,
  transpileCommaExpression: transpileCommaExpression,
  transpileArgList: transpileArgList,
  expandExpression: expandExpression,
  macroexpand: macros.expand,
  evalExpression: evalExpression,
  evalJavascript: handlers.evalJavascript
});

module.exports = {
  transpile: transpile,
  transpileExpression: transpileExpression,
  transpileExpressions: transpileExpressions,
  transpileCommaExpression: transpileCommaExpression,
  transpileArgList: transpileArgList,
  transpileOther: transpileOther,
  registerMacro: registerMacro
};
