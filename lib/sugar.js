// Generated by SugarLisp v0.5
require("./require");
var fs = require("fs"),
  path = require("path"),
  transpiler = require("./transpiler"),
  repl = require("./repl"),
  watch = require("watch"),
  isValidFlag = /-h\b|-r\b|-v\b|-b\b|-s\b/,
  error = function(err) {
    console.error(err.message)
  };
var opt = require('node-getopt').create([
  [
    'h',
    'help',
    'display this help'
  ],
  [
    'v',
    'version',
    'show version'
  ],
  [
    'r',
    'run',
    'compile and then run source files'
  ],
  [
    'w',
    'watch',
    'watch and compile changed files beneath current directory'
  ],
  [
    'f',
    'for=ARG',
    'compile for e.g. "client" or "server"'
  ],
  [
    't',
    'to=ARG',
    'compile to e.g. "core" or "json" (compiles to javascript by default)'
  ],
  [
    'b',
    'browser-bundle',
    'create sugarlisp-browser-bundle.js in the current directory'
  ],
  [
    'm',
    'map',
    'generate source map files'
  ],
  [
    '',
    'pretty[=PRETTY]',
    'beautify the output (defaults to true unless generating sourcemaps)'
  ]
]).setHelp(("sugar [OPTION] [<infile>] [<outfile>]\n\n" + "<outfile> will default to <infile> with appropriate (usually '.js') extension\n\n" + "Also compile stdin to stdout\n" + "eg. $ echo '(console.log \"hello\")' | sugar\n\n" + "[[OPTIONS]]\n\n")).bindHelp().parseSystem();
(function(___monad) {
  var mBind = ___monad.mBind,
    mResult = ___monad.mResult,
    mZero = ___monad.mZero,
    mPlus = ___monad.mPlus;
  var ____mResult = function(___arg) {
    return (((typeof(___arg) === "undefined") && ((!(typeof(mZero) === "undefined")))) ?
      mZero :
      mResult(___arg));
  };
  return mBind((((opt.argv.length === 0) && (Object.keys(opt.options).length === 0)) ?
    (function() {
      var input = process.stdin;
      var output = process.stdout;
      input.resume();
      input.setEncoding("utf8");
      var source = "";
      input.on("data", function(chunck) {
        return source = (source + chunck.toString());
      });
      input.on("end", function() {
        return output.write(transpiler.transpile(source, process.cwd(), {
          sourceMap: (true === opt.options['map']),
          to: opt.options['to'],
          for: opt.options['for'],
          pretty: opt.options['pretty']
        }));
      });
      input.on("error", error);
      output.on("error", error);
      setTimeout(function() {
        return ((input.bytesRead === 0) ?
          (function() {
            input.removeAllListeners("data");
            return repl.runrepl();
          })() : undefined);
      }, 20);
      return null;
    })() : undefined), function(noargs) {
    return mBind(((true === opt.options['version']) ?
      (function() {
        console.log(("Version " + transpiler.version));
        return null;
      })() :
      ((true === opt.options['browser-bundle']) ?
        (function() {
          var bundle = require.resolve("sugarlisp/lib/sugarlisp-browser-bundle.js");
          fs.createReadStream(bundle).pipe(fs.createWriteStream("sugarlisp-browser-bundle.js"));
          return null;
        })() :
        ((true === opt.options['run']) ?
          (function() {
            var infile = (opt.argv[0] ?
              (((opt.argv[0].indexOf('.slisp') === -1) && (opt.argv[0].indexOf('.ls') === -1) && (opt.argv[0].indexOf('.sugar') === -1) && (opt.argv[0].indexOf('.js') === -1)) ?
                error(new Error("Error: Input file does not have a recognized file extension")) :
                opt.argv[0]) :
              error(new Error("Error: No Input file given")));
            require(infile);
            return null;
          })() :
          ((true === opt.options['watch']) ?
            (function() {
              var cwd = process.cwd();
              console.log('Watching', cwd, 'for changes...');
              watch.watchTree(cwd, {
                filter: function(f, stat) {
                  return (stat.isDirectory() || (f.indexOf('.slisp') !== -1) || (f.indexOf('.ls') !== -1) || (f.indexOf('.sugar') !== -1) || (f.indexOf('.slml') !== -1) || (f.indexOf('.slss') !== -1) || (f.indexOf('.slson') !== -1));
                },
                ignoreDotFiles: true,
                ignoreDirectoryPattern: /node_modules/
              }, function(f, curr, prev) {
                return ((curr && (curr.nlink !== 0)) ?
                  require("child_process").spawn("sugar", [
                    f.substring((cwd.length + 1))
                  ], {
                    stdio: "inherit"
                  }) :
                  (((Object.prototype.toString.call(f) === "[object Object]") && (prev === null) && (curr === null)) ?
                    (function(o, f, s) {
                      var _k = Object.keys(o)
                      return _k.forEach(function(elem) {
                        return f.call(s, o[elem], elem, o);
                      });
                    })(f, function(stat, initialf) {
                      return (((!(initialf === cwd))) ?
                        (function() {
                          return (function() {
                            return require("child_process").spawn("sugar", [
                              initialf.substring((cwd.length + 1))
                            ], {
                              stdio: "inherit"
                            });
                          })();
                        })() : undefined);
                    }) : undefined));
              });
              return null;
            })() :
            (true ?
              true : undefined))))), function(compile) {
      return mBind((opt.argv[0] ?
        opt.argv[0] :
        error(new Error("Error: No Input file given"))), function(infile) {
        return mBind((function() {
          var outfile = opt.argv[1];
          (((!outfile)) ?
            (function() {
              return (function() {
                var ext = path.extname(infile);
                var fnameonly = path.basename(infile, ext);
                outfile = (fnameonly + ((ext === ".slml") ?
                  ".html" :
                  ((ext === ".slss") ?
                    "css" :
                    (true ?
                      ".js" : undefined))));
                return (([
                    ".slisp",
                    ".ls",
                    ".sugar",
                    ".slson",
                    ".slml",
                    ".slss"
                  ].indexOf(ext) === -1) ?
                  error(new Error(["Error: sugarlisp does not compile ", ext, " files"].join(''))) : undefined);
              })();
            })() : undefined);
          return outfile;
        })(), function(outfile) {
          return (function() {
            return ____mResult((function() {
              console.log('SugarLisp', ['v', transpiler.version, ':'].join(''), 'compiling', infile, 'to', outfile);
              return fs.writeFileSync(outfile, transpiler.transpile(fs.readFileSync(infile, "utf8"), fs.realpathSync(infile), {
                sourceMap: (true === opt.options['map']),
                to: opt.options['to'],
                for: opt.options['for'],
                pretty: opt.options['pretty']
              }), "utf8");
            })());
          })();
        });
      });
    });
  });
})({
  mBind: function(mv, mf) {
    return ((mv === null) ?
      null :
      mf(mv));
  },
  mResult: function(v) {
    return v;
  },
  mZero: null
});